import { computed, effect,Injectable, signal } from '@angular/core';

import { MenuItem } from '../models/layout.model';

@Injectable({ providedIn: 'root' })
export class SidebarNavService {
  // üîπ Se√±al privada que mantiene la lista completa de elementos del men√∫
  private readonly _menuItems = signal<MenuItem[]>([
    { id: 1, url: '/', label: '', name: 'Home', href: '/home', icon: 'home', iconComponent: undefined, title: '', variant: '', divider: false },
    { id: 2, url: '/dashboard', label: '', name: 'Dashboard', href: '/dashboard', icon: 'home', iconComponent: undefined, title: '', variant: '', divider: false },
    { id: 3, url: '/', label: '', name: 'Settings', href: '/settings', icon: 'home', iconComponent: undefined, title: '', variant: '', divider: false },
    { id: 4, url: '/', label: '', name: 'Profile', href: '/profile', icon: 'home', iconComponent: undefined, title: '', variant: '', divider: false },
  ]);

  // üîπ Se√±al privada para t√©rmino de b√∫squeda
  private readonly _searchTerm = signal<string>('');

  // üîπ Se√±al p√∫blica solo lectura: lista completa del men√∫
  public readonly menuItems = this._menuItems.asReadonly();

  // üîπ Se√±al p√∫blica solo lectura: t√©rmino de b√∫squeda
  public readonly searchTerm = this._searchTerm.asReadonly();

  // üîπ Computed: lista filtrada seg√∫n el t√©rmino de b√∫squeda
  public readonly filteredMenuItems = computed(() => {
    const term = this._searchTerm().toLowerCase();
    if (!term) return this._menuItems();
    return this._menuItems().filter(item =>
      item.name.toLowerCase().includes(term)
    );
  });

  // üîπ Effect opcional: log cuando cambia la lista filtrada (para debug)
  private readonly filteredEffect = effect(() => {
    console.log('Menu filtrado actualizado:', this.filteredMenuItems());
  });

  // ==============================
  // üîπ M√©todos p√∫blicos
  // ==============================

  /** Agrega un nuevo item al men√∫ */
  public addMenuItem(item: MenuItem): void {
    const nextId = Math.max(...this._menuItems().map(i => i.id), 0) + 1;
    this._menuItems.set([...this._menuItems(), { ...item, id: nextId }]);
  }

  /** Actualiza un item existente */
  public updateMenuItem(id: number, updatedItem: Partial<MenuItem>): void {
    const current = [...this._menuItems()];
    const index = current.findIndex(i => i.id === id);
    if (index !== -1) {
      current[index] = { ...current[index], ...updatedItem };
      this._menuItems.set(current);
    }
  }

  /** Elimina un item por ID */
  public deleteMenuItem(id: number): void {
    this._menuItems.set(this._menuItems().filter(i => i.id !== id));
  }

  /** Actualiza el t√©rmino de b√∫squeda */
  public searchMenuItems(term: string): void {
    this._searchTerm.set(term);
  }

  /** Reemplaza toda la lista del men√∫ */
  public setMenuItems(items: MenuItem[]): void {
    this._menuItems.set([...items]);
  }

  /** Limpia el t√©rmino de b√∫squeda */
  public clearSearch(): void {
    this._searchTerm.set('');
  }
}
